#!/bin/bash

# Update the harmonyservices/harmony and harmonyservices/query-cmr images and optionally
# update service images

source "packages/util/env-defaults"
source "services/harmony/env-defaults"
source ".env"

# set -e

SELF=$(basename $0)

function usage
{
  echo -e "\033[1mUSAGE\033[0m"
  echo -e "\033[1m$SELF\033[0m [-h|--help] [-s|--services]"
  echo "  -s|--services     Update service images in addition to harmony images."
  echo "  -h|--help         Print this message."
  echo -e "\033[1mDESCRIPTION\033[0m"
  echo "This script updates the Docker images used internally by Harmony then restarts Harmony."
  echo "Optionally it can also update the service images."
}

RELOAD_SERVICES=false

while [[ $# -gt 0 ]]
do
key="$1"

case $key in
  -s|--services)
  RELOAD_SERVICES=true
  shift
  ;;
  -h|--help)
  usage && exit 0
  ;;
  *)
  usage && exit 1
  ;;
esac
done

if [ "$RELOAD_SERVICES" = true ]; then
  # read all the image env vars from both services.yml files
  image_vars=()
  while read -r line; do
    if [[ $line =~ ^.*image:[[:space:]]+!Env[[:space:]]+\$\{(.*)\} ]]; then
      image_var=${BASH_REMATCH[1]}
      if [[ ! " ${image_vars[@]} " =~ " ${image_var} " ]]; then
        image_vars+=( "$image_var" )
      fi
    fi
  done < ./config/services-uat.yml

  while read -r line; do
    if [[ $line =~ ^.*image:[[:space:]]+!Env[[:space:]]+\$\{(.*)\} ]]; then
      image_var=${BASH_REMATCH[1]}
      if [[ ! " ${image_vars[@]} " =~ " ${image_var} " ]]; then
        image_vars+=( "$image_var" )
      fi
    fi
  done < ./config/services-prod.yml

  referenced_images=()
  for img_var in ${image_vars[@]}; do
    referenced_images+=( "${!img_var}" )
  done

  # read all the images that are in the local Docker cache
  pulled_images=()
  IFS=$'\n' lines=(`docker images --format "{{.Repository}}:{{.Tag}}"`)
  for line in ${lines[@]}; do
    if [[ $line =~ ^(.+):(.+) ]]; then
      image_tag="${BASH_REMATCH[1]}:${BASH_REMATCH[2]}"
      if [[ ! " ${pulled_images[@]} " =~ " ${image_tag} " ]]; then
        pulled_images+=( "$image_tag" )
      fi
    fi
  done
fi

# create a list of images that are in both of the previous lists
all_images=()
while read -r line; do
  all_images+=( "$line" )
done < <(sort <(echo "${referenced_images[*]}") <(echo "${pulled_images[*]}") | uniq -d)

# Use the arm64 version of the stable images if on an arm64 machine unless an explicit image has been set
if [[ $(uname -m) == 'arm64' ]]; then
  echo "We appear to be running on an arm64 platform"
  if [[ -z "$HARMONY_IMAGE" ]]; then
    export HARMONY_IMAGE=harmonyservices/harmony:stable-arm64
  fi
  if [[ -z "$SERVICE_RUNNER_IMAGE" ]]; then
    export SERVICE_RUNNER_IMAGE=harmonyservices/service-runner:stable-arm64
  fi
  if [[ -z "$QUERY_CMR_IMAGE" ]]; then
    export QUERY_CMR_IMAGE=harmonyservices/query-cmr:stable-arm64
  fi
  if [[ -z "$WORK_ITEM_SCHEDULER_IMAGE" ]]; then
    export WORK_ITEM_SCHEDULER_IMAGE=harmonyservices/work-scheduler:stable-arm64
  fi
  if [[ -z "$WORK_ITEM_UPDATER_IMAGE" ]]; then
    export WORK_ITEM_UPDATER_IMAGE=harmonyservices/work-updater:stable-arm64
  fi
  if [[ -z "$WORK_FAILER_IMAGE" ]]; then
    export WORK_FAILER_IMAGE=harmonyservices/work-failer:stable-arm64
  fi
  if [[ -z "$CRON_SERVICE_IMAGE" ]]; then
    export CRON_SERVICE_IMAGE=harmonyservices/cron-service:stable-arm64
  fi
fi

# always reload the harmony image, query-cmr, service-runner, and all core service images
all_images+=( "$HARMONY_IMAGE" "$QUERY_CMR_IMAGE" "$SERVICE_RUNNER_IMAGE" "$WORK_ITEM_UPDATER_IMAGE" "$WORK_ITEM_SCHEDULER_IMAGE" "$WORK_FAILER_IMAGE" "$CRON_SERVICE_IMAGE" )

for image in ${all_images[@]}; do
  echo "${image}"
  docker pull "${image}" > /dev/null 2>&1
  if [ $? -eq 0 ]; then
    echo "${image} successfully updated"
  else
    echo "WARNING: ${image} could not be updated"
  fi
done

# restart harmony
./bin/reload-services-config
